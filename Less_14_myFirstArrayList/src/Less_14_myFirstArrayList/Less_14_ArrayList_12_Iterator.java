package Less_14_myFirstArrayList;

import java.util.*;

/*
Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator().
Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.

Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить
следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент,
и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true.
Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции
метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий
элемент, который был получен последним вызовом next().

Интерфейс Iterator предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет
другой итератор - интерфейс ListIterator. Данный итератор используется классами, реализующими интерфейс
List, то есть классами LinkedList, ArrayList и др.

Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:
- void add(E obj): вставляет объект obj перед элементом, который должен быть возвращен следующим
вызовом next();
- boolean hasNext(): возвращает true, если в коллекции имеется следующий элемент, иначе
возвращает false;
- boolean hasPrevious(): возвращает true, если в коллекции имеется предыдущий элемент, иначе
возвращает false;
- E next(): возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется
исключение NoSuchElementException;
- E previous(): возвращает текущий элемент и переходит к предыдущему, если такого нет, то
генерируется исключение NoSuchElementException;
- int nextIndex(): возвращает индекс следующего элемента. Если такого нет, то возвращается
размер списка;
- int previousIndex(): возвращает индекс предыдущего элемента. Если такого нет, то возвращается
число -1;
- void remove(): удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван
после методов next() или previous(), иначе будет сгенерировано исключение IlligalStateException;
- void set(E obj): присваивает текущему элементу, выбранному вызовом методов next() или previous(),
ссылку на объект obj;
*/
public class Less_14_ArrayList_12_Iterator {
    public static void main(String[] args) {
        List<Integer> int_list_1 = Arrays.asList(2,4,-1,45,23,1,0,45,71);
        List<Integer> int_list_2 = new ArrayList<>();
        int_list_2.add(6);
        int_list_2.add(21);
        int_list_2.add(-34);
        int_list_2.add(45);
        int_list_2.add(123);
        int_list_2.add(1);
        int_list_2.add(50);
        int_list_2.add(45);
        int_list_2.add(71);

        // Создаем итератор
        Iterator<Integer> iter = int_list_1.iterator();
        // Запускаем цикл, с условием, есть ли следующий элемент итератора
        while (iter.hasNext()){
            // Вывести на печать следующий элемент итератора
            System.out.print(iter.next() + " ");
        }
        System.out.println("\n--------------------------------------------------------------");

        System.out.println();
        // Создаем ЛистИтератор, он более развернутый, чем просто итератор, читать выше
        ListIterator<Integer> iter_2 = int_list_2.listIterator();
        // Есть ли следующий элемент ЛистИтератора
        while (iter_2.hasNext()){
            // Берем следующий элемент итератора, если он есть
            iter_2.next();
            /* Удаляем взятый элемент, при наличии (фактически этот код вычищает весь лист под ноль),
            но есть исключение -> !!! Если лист был создан методом asList, например ->
            'List<Integer> int_list_1 = Arrays.asList(2,4,-1,45,23,1,0,45,71);'
            мы получаем неизменяемую коллекцию и метод *.remove() будет выкидывать исключение:
            'Exception in thread "main" java.lang.UnsupportedOperationException'
            */
            iter_2.remove();
        }
        System.out.println("Печатаем лист после ЛистИтератора с методом *.remove()");
        for (Integer int_for_prn:int_list_2) {
            System.out.print(int_for_prn + " ");
        }
    }
}

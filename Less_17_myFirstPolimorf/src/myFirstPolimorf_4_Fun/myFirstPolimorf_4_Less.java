package myFirstPolimorf_4_Fun;
/*
Данная задачка интересна если ее рассматривать в блокноте, без подсказок
среды разработки. Нужно просмотреть код и сказать, что выйдет в консоли.
*/
public class myFirstPolimorf_4_Less {
    public static void main(String[] args) {
        /*
        Ссылочная переменная sml от класса SmallAnimal, указывает на объект Bat.
        */
        SmallAnimal sml = new Bat();
        /*
        Теперь мы обращаемся к перегруженному методу canRun, поскольку переменная хоть и ссылается на
        объект Bat, создана она классом SmallAnimal, а значит сначала пойдут в работу его методы. А если
        быть еще более точным, то только в этом классе есть требуемый метод. Поскольку Bat потомок и его
        объект передается в качестве аргумента, то ничто не мешает запустить метод 'void canRun(SmallAnimal sm)'
        класса родителя.
        */
        sml.canRun(new Bat()); // Зверек бежит
        /*
        Да, мы можем кастомизировать запуск метода, через явное указание класса
        */
        ((Bat)sml).canRun(new Bat()); // Летучая мышь ползет
        /*
        А, вот тут кастомизация не повлияет на результат вывода, презаписанный метод перекроет,
        метод класса родителя Mouse
        */
        ((Mouse)sml).canRun(new Bat()); // Летучая мышь ползет

        Mouse mouse = new Mouse();
        mouse.canRun(new Bat()); // Мышь бежит
    }
}

class SmallAnimal{
    void canRun(SmallAnimal sm){
        System.out.println("Зверек бежит");
    }
}

class Mouse extends SmallAnimal{
    /*
    При том, что в дочернем классе есть одноименный метод, он имеет другие аргументы на входе,
    а значит, он не перезаписан, а перегружен !!! Т.е. в классе Mouse, бледной тенью присутствует
    метод 'void canRun(SmallAnimal sm)' со своим кодом на выполнение (если глаз не наметан,
    как у меня, то восприятие без подсказок искажено).
    */
    void canRun(Mouse m1) {
        System.out.println("Мышь бежит");;
    }
}

class Bat extends Mouse{
    /*
    В данном классе, наследнике Mouse метод 'canRun(Mouse m2)' уже перезаписан, но одноименный
    метод супер-прородителя SmallAnimal тут тоже есть, снова невидимо, но есть. А теперь если
    перейти в main метод ->
    */
    @Override
    void canRun(Mouse m2) {
        System.out.println("Летучая мышь ползет");;
    }
}
